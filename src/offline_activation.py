"""Lambda handler: POST /activations/offline

Creates an offline activation for a Cryptlex license.

The caller authenticates using their own Cryptlex credentials.

Request body (JSON):
    email             (str, required): Cryptlex account email.
    password          (str, required): Cryptlex account password.
    accountId         (str, required): Cryptlex account ID.
    license_id        (str, required): The Cryptlex license ID.
    offline_request   (str, required): The encrypted offline activation request
                                       string generated by LexActivator.
    response_validity (int, required): Duration in seconds for which the offline
                                       response remains valid.

Response (200):
    The offline activation response from Cryptlex (typically an encrypted blob
    that the client feeds back into LexActivator).
"""

import json
import logging
import traceback

import requests

from src.cryptlex_client import authenticate, create_offline_activation

logger = logging.getLogger()
logger.setLevel(logging.INFO)

_FIELD_MAP = {
    "license_id": "licenseId",
    "offline_request": "offlineRequest",
    "response_validity": "responseValidity",
}


def _normalize_body(body):
    out = {}
    for key, value in body.items():
        out[_FIELD_MAP.get(key, key)] = value
    return out


def _response(status_code, body):
    return {
        "statusCode": status_code,
        "headers": {"Content-Type": "application/json"},
        "body": json.dumps(body) if isinstance(body, dict) else body,
    }


def handler(event, context):
    # --- Parse body ---
    try:
        body = json.loads(event.get("body") or "{}")
    except (json.JSONDecodeError, TypeError):
        return _response(400, {"error": "Invalid JSON in request body."})

    # Extract credentials before normalizing the rest.
    email = body.get("email")
    password = body.get("password")
    account_id = body.get("accountId")

    if not email or not password or not account_id:
        return _response(400, {"error": "email, password, and accountId are required."})

    body = _normalize_body(body)

    license_id = body.get("licenseId")
    offline_request = body.get("offlineRequest")
    response_validity = body.get("responseValidity")

    if not license_id:
        return _response(400, {"error": "license_id is required."})
    if not offline_request:
        return _response(400, {"error": "offline_request is required."})
    if not response_validity:
        return _response(400, {"error": "response_validity is required (seconds)."})

    try:
        response_validity = int(response_validity)
    except (ValueError, TypeError):
        return _response(400, {"error": "response_validity must be an integer."})

    # --- Authenticate to Cryptlex ---
    try:
        access_token = authenticate(email, password, account_id)
    except requests.HTTPError as exc:
        status = exc.response.status_code if exc.response is not None else 502
        detail = exc.response.text if exc.response is not None else str(exc)
        logger.error("Cryptlex auth failed: %s %s", status, detail)
        return _response(401, {"error": "Cryptlex authentication failed.", "detail": detail})

    # --- Create offline activation ---
    try:
        result = create_offline_activation(access_token, license_id, offline_request, response_validity)
        logger.info("Offline activation created for license: %s", license_id)
        return {
            "statusCode": 200,
            "headers": {"Content-Type": "application/octet-stream"},
            "body": result,
            "isBase64Encoded": False,
        }

    except requests.HTTPError as exc:
        status = exc.response.status_code if exc.response is not None else 502
        detail = exc.response.text if exc.response is not None else str(exc)
        logger.error("Cryptlex API error: %s %s", status, detail)
        return _response(status, {"error": "Cryptlex API error", "detail": detail})

    except Exception:
        logger.error("Unhandled error: %s", traceback.format_exc())
        return _response(500, {"error": "Internal server error."})
