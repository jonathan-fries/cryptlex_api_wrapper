import time

import requests

from src.config import CRYPTLEX_BASE_URL, get_cryptlex_credentials

# Module-level token cache â€” survives across invocations in the same
# Lambda execution environment, avoiding a login call on every request.
_token_cache = {
    "access_token": None,
    "expires_at": 0,
}


def _authenticate():
    """Log in to Cryptlex and cache the access token."""
    creds = get_cryptlex_credentials()

    resp = requests.post(
        f"{CRYPTLEX_BASE_URL}/accounts/login",
        json={
            "accountId": creds["account_id"],
            "email": creds["email"],
            "password": creds["password"],
        },
        headers={"Content-Type": "application/json"},
        timeout=15,
    )
    resp.raise_for_status()
    data = resp.json()

    # Cache for 55 minutes (Cryptlex tokens typically last 1 hour).
    _token_cache["access_token"] = data["accessToken"]
    _token_cache["expires_at"] = time.time() + 55 * 60

    return data["accessToken"]


def _get_token():
    """Return a valid access token, refreshing if necessary."""
    if _token_cache["access_token"] and time.time() < _token_cache["expires_at"]:
        return _token_cache["access_token"]
    return _authenticate()


def _auth_headers():
    return {
        "Authorization": f"Bearer {_get_token()}",
        "Content-Type": "application/json",
    }


def create_license(product_id, **kwargs):
    """Create a new Cryptlex license.

    Args:
        product_id: The Cryptlex product ID.
        **kwargs: Optional license parameters forwarded to the Cryptlex API
                  (e.g. allowedActivations, validity, type, metadata, etc.).

    Returns:
        dict: The created license object from Cryptlex.
    """
    body = {"productId": product_id}
    body.update(kwargs)

    resp = requests.post(
        f"{CRYPTLEX_BASE_URL}/licenses",
        json=body,
        headers=_auth_headers(),
        timeout=15,
    )
    resp.raise_for_status()
    return resp.json()


def create_offline_activation(license_id, offline_request, response_validity):
    """Create an offline activation for a license.

    Args:
        license_id: The Cryptlex license ID.
        offline_request: The encrypted offline activation request string
                         (generated by LexActivator on the client machine).
        response_validity: Duration in seconds for which the offline
                           response should remain valid.

    Returns:
        The offline activation response content from Cryptlex.
    """
    body = {
        "licenseId": license_id,
        "offlineRequest": offline_request,
        "responseValidity": response_validity,
    }

    resp = requests.post(
        f"{CRYPTLEX_BASE_URL}/activations/offline-activate",
        json=body,
        headers=_auth_headers(),
        timeout=15,
    )
    resp.raise_for_status()
    return resp.text  # Response may be a binary/text blob, not JSON
